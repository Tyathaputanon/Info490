# -*- coding: utf-8 -*-
"""INFO490PlottingPotter

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hlLr-EmWBgarQXKYcjU41OjXisnymFAk
"""

HP_URL ='https://raw.githubusercontent.com/NSF-EC/INFO490Assets/master/src/datasets/books/hp/harryPotter.txt'

import requests
def read_remote(url):
  response = requests.get(url)
  response.encoding = 'utf-8'
  if response.status_code == requests.codes.ok:
      # that is 200
      return response.text
  return None

text = read_remote(HP_URL) # see lesson.py
# print(len(text))

import numpy as np
import re
# def clean_hp(text):
#   normalized_text = text.lower()
#   up_to_word = "normalize whitespace between chapter headings, titles and text"
#   rx_to_first = r'^.*?{}'.format(re.escape(up_to_word))
#   clean_beginning = (re.sub(rx_to_first, '',text, flags=re.DOTALL).strip())
#   clean_ending = clean_beginning.split("249",1)[0]+'249'
#   return clean_ending

def clean_hp(text):
  start = text.find("Harry Potter and the Sorcerer's Stone")
  regex = re.compile(r'\n\n\nHarry Potter and the Sorcerer\'s Stone\n\n')
  for i in regex.finditer(text):
    end = text.find("FINIS")
    text = text[i.start()+3:]
    text = text.strip()
    return text

hp = clean_hp(text)
#print(len(hp))
#print(hp)

def split_into_chapters(text):
  regex = re.compile(r'CHAPTER')
  chapterIndices = []
  chapters = []
  for i in regex.finditer(text):
    chapterIndices.append(i.start())
  for i in range(len(chapterIndices)):
    if i == len(chapterIndices)-1:
      currChapter = text[chapterIndices[i]:]
    else:
      currChapter = text[chapterIndices[i]:chapterIndices[i+1]]
    currChapter = currChapter.strip()
    chapters.append(currChapter)
  return chapters

text = read_remote(HP_URL)
hp   = clean_hp(text)
chp  = split_into_chapters(hp)

#print (chp)
# print(len(chp))     # 17
# print(chp[0][0:18]) # THE BOY WHO LIVED
# print(chp[1][0:18]) # THE VANISHING GLAS

import numpy as np

def get_character_counts_v1(chapters):
  harry_by_chapter    = np.char.count(chapters, "Harry")
  harry = harry_by_chapter.T

  ron_by_chapter    = np.char.count(chapters, "Ron")
  ron = ron_by_chapter.T

  hagrid_by_chapter   = np.char.count(chapters, "Hagrid")
  hagrid = hagrid_by_chapter.T

  hermione_by_chapter = np.char.count(chapters, "Hermione") 
  hermione = hermione_by_chapter.T

  return (harry, ron, hagrid, hermione)

chapters = split_into_chapters(hp)

print(get_character_counts_v1(chapters))

import matplotlib.pyplot as plt

def simple_graph_v1(a,b,c,d):

  fig = plt.figure()

  subplot = fig.add_subplot(1,1,1)


  subplot.plot(a)

  subplot.plot(b)

  subplot.plot(c)

  subplot.plot(d) 

  return fig  # this is important for testing


# simple_graph_v1(harry_by_chapter,\

# ron_by_chapter, hagrid_by_chapter,\

# hermione_by_chapter) 

def pipeline_v1():

  text = read_remote(HP_URL)
  hp   = clean_hp(text)
  chapters = split_into_chapters(hp)

  plots = get_character_counts_v1(chapters)
  fig = simple_graph_v1(plots)
  return fig

def get_character_counts_v2(chapters, names):
  counts = np.array([np.char.count(chapters,n) for n in names])
  counts = np.array([np.cumsum(count) for count in counts])
  counts = counts.T
  return counts

who = ["Ron", "Hagrid"] 
data = get_character_counts_v2(chapters, who)
# print(data)
# print(data.shape)

def pipeline_v2(names):

  text = read_remote(HP_URL)
  hp   = clean_hp(text)
  chapters = split_into_chapters(hp)
 
  return get_character_counts_v2(chapters, names)

who = ["Harry", "Ron", "Hagrid", "Hermione"]
#print(pipeline_v2(who))

def simple_graph_v2(counts):
  fig = plt.figure()
  subplot = fig.add_subplot(1,1,1)
  subplot.plot(counts)
  return fig  # return the figure

who = ["Harry", "Ron", "Hagrid", "Hermione"]
data = pipeline_v2(who)
fig = simple_graph_v2(data)